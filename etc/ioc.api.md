## API Report File for "@mscharley/ioc"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export type ArgsForTokens<Tokens extends [...Array<ConstructorInjection<unknown>>]> = {
    [Index in keyof Tokens]: ConstructorInjectedType<Tokens[Index]>;
} & {
    length: Tokens['length'];
};

// @public
type AsyncContainerModule = (bind: BindFunction, unbind: UnbindFunction, isBound: IsBoundFunction, rebind: RebindFunction) => Promise<void>;

// @public (undocumented)
interface Binder<in out T> {
    // (undocumented)
    toConstantValue: ((v: T) => void) & ((v: Promise<T>) => Promise<void>);
    // (undocumented)
    toDynamicValue: (fn: (context: BindingContext<T>) => T | Promise<T>) => void;
}

// @public (undocumented)
type BindFunction = {
    <T extends object>(id: Constructor<T>): ClassBindingBuilder<T>;
    <T extends object>(id: ServiceIdentifier<T>): ObjectBindingBuilder<T>;
    <T>(id: ServiceIdentifier<T>): BindingBuilder<T>;
};

// @public (undocumented)
interface BindingBuilder<in out T> extends Binder<T>, BindingScope<T, BindingBuilder<T>> {
}

// @public (undocumented)
interface BindingContext<out T> {
    // (undocumented)
    container: Container;
    // (undocumented)
    id: ServiceIdentifier<T>;
}

// @public (undocumented)
interface BindingScope<in T, out Builder> {
    // (undocumented)
    inRequestScope: () => Omit<Builder, FixedScopeBindingOptions | keyof BindingScope<T, unknown>>;
    // (undocumented)
    inSingletonScope: () => Omit<Builder, FixedScopeBindingOptions | keyof BindingScope<T, unknown>>;
    // (undocumented)
    inTransientScope: () => Omit<Builder, FixedScopeBindingOptions | keyof BindingScope<T, unknown>>;
}

// @public (undocumented)
interface ClassBinder<in T> {
    // (undocumented)
    toSelf: () => void;
}

// @public (undocumented)
interface ClassBindingBuilder<in out T extends object> extends Binder<T>, BindingScope<T, ClassBindingBuilder<T>>, ObjectBinder<T>, ClassBinder<T> {
}

// @public
type Constructor<out T extends object, in Args extends unknown[] = any> = new (...args: Args) => T;

// @public (undocumented)
export type ConstructorInjectedType<T extends ConstructorInjection<unknown>> = T extends interfaces.ServiceIdentifier<infer U> ? U : T extends [interfaces.ServiceIdentifier<infer U>] ? U : never;

// @public (undocumented)
export type ConstructorInjection<T> = interfaces.ServiceIdentifier<T> | [interfaces.ServiceIdentifier<T>, Partial<interfaces.InjectOptions>];

// Warning: (ae-unresolved-link) The @link reference could not be resolved: This type of declaration is not supported yet by the resolver
//
// @public
interface Container {
    // (undocumented)
    bind: BindFunction;
    // (undocumented)
    readonly config: ContainerConfiguration;
    // (undocumented)
    createChild: (options?: Partial<ContainerConfiguration>) => Container;
    get: {
        <T>(id: ServiceIdentifier<T>, options: Partial<InjectOptions> & {
            multiple: true;
        }): Promise<T[]>;
        <T>(id: ServiceIdentifier<T>, options: Partial<InjectOptions> & {
            optional: true;
        }): Promise<T | undefined>;
        <T>(id: ServiceIdentifier<T>, options?: Partial<InjectOptions>): Promise<T>;
    };
    // (undocumented)
    has: IsBoundFunction;
    // (undocumented)
    load: {
        (module: AsyncContainerModule): Promise<void>;
        (module: SyncContainerModule): void;
    };
    // (undocumented)
    rebind: RebindFunction;
    // (undocumented)
    unbind: UnbindFunction;
}

// @public
interface ContainerConfiguration {
    defaultScope: ScopeOptions;
    logger: Logger;
    logLevel: LoggerLevel;
    // @internal
    parent?: Container;
}

// @public
type ContainerModule = AsyncContainerModule | SyncContainerModule;

// Warning: (ae-unresolved-link) The @link reference could not be resolved: This type of declaration is not supported yet by the resolver
//
// @public
export const createContainer: (config?: interfaces.ContainerConfiguration) => interfaces.Container;

// @public (undocumented)
type FixedScopeBindingOptions = 'toConstantValue';

// @public (undocumented)
export const inject: InjectDecoratorFactory;

// @public (undocumented)
export const injectable: <Tokens extends ConstructorInjection<unknown>[]>(...constructorTokens: Tokens) => InjectableDecorator<ArgsForTokens<Tokens>>;

// @public (undocumented)
export interface InjectableDecorator<Args extends unknown[]> {
    // (undocumented)
    <T extends object>(target: interfaces.Constructor<T, Args>, context: ClassDecoratorContext<interfaces.Constructor<T, Args>>): undefined;
    // (undocumented)
    <T extends object>(target: interfaces.Constructor<T, Args>, context?: undefined): undefined | interfaces.Constructor<T, Args>;
}

// @public (undocumented)
export interface InjectDecorator<T> {
    // (undocumented)
    (target: undefined, context: ClassFieldDecoratorContext<unknown, T>): (originalValue: T | undefined) => T;
    // (undocumented)
    (target: {
        constructor: Function;
    }, propertyName: string | symbol): undefined;
}

// @public (undocumented)
export interface InjectDecoratorFactory {
    // (undocumented)
    <T>(token: Token<T>, options: Partial<interfaces.InjectOptions> & {
        multiple: true;
    }): InjectDecorator<T[]>;
    // (undocumented)
    <T>(token: Token<T>, options: Partial<interfaces.InjectOptions> & {
        optional: true;
    }): InjectDecorator<T | undefined>;
    // (undocumented)
    <T>(token: Token<T>, options?: Partial<interfaces.InjectOptions>): InjectDecorator<T>;
}

// @public (undocumented)
interface InjectOptions {
    // (undocumented)
    multiple: boolean;
    // (undocumented)
    optional: boolean;
}

declare namespace interfaces {
    export {
        Binder,
        FixedScopeBindingOptions,
        BindingBuilder,
        ClassBindingBuilder,
        ObjectBindingBuilder,
        BindingContext,
        BindingScope,
        ClassBinder,
        Constructor,
        Container,
        ContainerConfiguration,
        AsyncContainerModule,
        ContainerModule,
        SyncContainerModule,
        BindFunction,
        IsBoundFunction,
        RebindFunction,
        UnbindFunction,
        InjectOptions,
        Logger,
        LoggerLevel,
        ObjectBinder,
        ScopeOptions,
        ServiceIdentifier
    }
}
export { interfaces }

// @public (undocumented)
type IsBoundFunction = <T>(id: ServiceIdentifier<T>) => boolean;

// @public (undocumented)
type Logger = Record<LoggerLevel, {
    (obj: Record<string, unknown>, message: string): void;
    (msg: string): void;
}>;

// @public (undocumented)
type LoggerLevel = 'info' | 'debug' | 'trace';

// @public (undocumented)
interface ObjectBinder<in out T extends object> {
    // (undocumented)
    to: (fn: Constructor<T>) => void;
}

// @public (undocumented)
interface ObjectBindingBuilder<in out T extends object> extends Binder<T>, BindingScope<T, ObjectBindingBuilder<T>>, ObjectBinder<T> {
}

// @public (undocumented)
type RebindFunction = BindFunction;

// @public (undocumented)
type ScopeOptions = 'transient' | 'request' | 'singleton';

// @public
type ServiceIdentifier<T> = Token<T> | (T extends object ? Constructor<T> : never);

// @public
type SyncContainerModule = (bind: BindFunction, unbind: UnbindFunction, isBound: IsBoundFunction, rebind: RebindFunction) => void;

// @public
export class Token<out T> {
    constructor(name: string);
    // @internal (undocumented)
    readonly identifier: symbol;
}

// @public
export type TokenType<T extends Token<unknown>> = T extends Token<infer U> ? U : never;

// @public (undocumented)
type UnbindFunction = <T>(id: ServiceIdentifier<T>) => void;

```
