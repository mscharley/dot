## API Report File for "@mscharley/dot"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type AnyToken<T> = Token<T> | MetadataToken<T, interfaces.MetadataObject>;

// @public
type ArgsForInjectionIdentifiers<Tokens extends [...Array<InjectionIdentifier<unknown>>]> = {
    [Index in keyof Tokens]: InjectedType<Tokens[Index]>;
} & {
    length: Tokens['length'];
};

// @public
type AsyncContainerModule = (bind: BindFunction, unbind: UnbindFunction, isBound: IsBoundFunction, rebind: RebindFunction) => Promise<void>;

// @public
interface Binder<in out T, in out Metadata extends MetadataObject> {
    toConstantValue: ((v: T) => void) & ((v: Promise<T>) => Promise<void>);
    toDynamicValue: <Tokens extends Array<InjectionIdentifier<unknown>>>(dependencies: [...Tokens], fn: Fn<T | Promise<T>, ArgsForInjectionIdentifiers<Tokens>>) => void;
    toFactory: <Tokens extends Array<InjectionIdentifier<unknown>>>(dependencies: [...Tokens], fn: (context: FactoryContext<Metadata>) => Fn<T | Promise<T>, ArgsForInjectionIdentifiers<Tokens>>) => void;
}

// @public
type BindFunction = {
    <Id extends Constructor<any, any>>(id: Id): ClassBindingBuilder<InjectedType<Id>, MetadataObject>;
    <Id extends Exclude<ServiceIdentifier<object>, Constructor<any, any>>>(id: Id): ObjectBindingBuilder<InjectedType<Id>, MetadataForIdentifier<Id>>;
    <Id extends ServiceIdentifier<unknown>>(id: Id): BindingBuilder<InjectedType<Id>, MetadataForIdentifier<Id>>;
};

// @public
interface BindingBuilder<in out T, in out Metadata extends MetadataObject> extends Binder<T, Metadata>, BindingMetadata<T, Metadata, BindingBuilder<T, Metadata>>, BindingScope<T, BindingBuilder<T, Metadata>> {
}

// @public
interface BindingMetadata<in out T, in out Metadata, out Builder> {
    // (undocumented)
    withMetadata: (metadata: Metadata) => Omit<Builder, keyof BindingMetadata<T, Metadata, unknown>>;
}

// @public
interface BindingScope<in T, out Builder> {
    inRequestScope: () => Omit<Builder, ImplicitScopeBindingOptions | keyof BindingScope<T, unknown>>;
    inSingletonScope: () => Omit<Builder, ImplicitScopeBindingOptions | keyof BindingScope<T, unknown>>;
    inTransientScope: () => Omit<Builder, ImplicitScopeBindingOptions | keyof BindingScope<T, unknown>>;
}

// @public
interface ClassBinder<in T> {
    toSelf: () => void;
}

// @public
interface ClassBindingBuilder<in out T extends object, in out Metadata extends MetadataObject> extends Binder<T, Metadata>, BindingMetadata<T, Metadata, ClassBindingBuilder<T, Metadata>>, BindingScope<T, ClassBindingBuilder<T, Metadata>>, ObjectBinder<T>, ClassBinder<T> {
}

// @public
interface ClassDecorator_2<T, Args extends unknown[]> {
    // (undocumented)
    <Ctr extends interfaces.Constructor<T, Args>>(target: Ctr, context: ClassDecoratorContext<Ctr>): undefined;
    // (undocumented)
    <Ctr extends interfaces.Constructor<T, Args>>(target: Ctr, context?: undefined): Ctr | undefined;
}
export { ClassDecorator_2 as ClassDecorator }

// @public
export interface ClassFieldDecorator<T extends object, Property> {
    // (undocumented)
    (target: undefined, context: ClassFieldDecoratorContext<T, Property>): (originalValue: Property | undefined) => Property;
    // (undocumented)
    (target: T, propertyName: string | symbol): undefined;
}

// @public
type Constructor<out T, in Args extends unknown[] = any> = new (...args: Args) => T;

// Warning: (ae-unresolved-link) The @link reference could not be resolved: This type of declaration is not supported yet by the resolver
//
// @public
interface Container {
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
    //
    // (undocumented)
    bind: BindFunction;
    readonly config: ContainerConfiguration;
    createChild: ContainerFactory;
    get: {
        <Id extends ServiceIdentifier<unknown>>(id: Id, options: {
            multiple: true;
        } & Partial<InjectOptions<MetadataForIdentifier<Id>>>): Promise<InjectedType<[Id, typeof options]>>;
        <Id extends ServiceIdentifier<unknown>>(id: Id, options: {
            optional: true;
        } & Partial<InjectOptions<MetadataForIdentifier<Id>>>): Promise<InjectedType<[Id, typeof options]>>;
        <Id extends ServiceIdentifier<unknown>>(id: Id, options?: Partial<InjectOptions<MetadataForIdentifier<Id>>>): Promise<InjectedType<[Id, typeof options]>>;
    };
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
    //
    // (undocumented)
    has: IsBoundFunction;
    load: <M extends ContainerModule>(module: M) => ReturnType<M>;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
    //
    // (undocumented)
    rebind: RebindFunction;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
    //
    // (undocumented)
    unbind: UnbindFunction;
    validate: (validateAutobindings?: boolean) => void;
}

// @public
interface ContainerConfiguration {
    readonly autobindClasses: boolean;
    readonly defaultScope: ScopeOptions;
    readonly logger: Logger;
    readonly logLevel: LoggerLevel;
    // @internal
    readonly parent?: Container;
}

// @public
type ContainerFactory = (options?: Partial<ContainerConfiguration>) => Container;

// @public
type ContainerModule = AsyncContainerModule | SyncContainerModule;

// Warning: (ae-unresolved-link) The @link reference could not be resolved: This type of declaration is not supported yet by the resolver
//
// @public
export const createContainer: interfaces.ContainerFactory;

// @public
type DirectInjection<T> = {
    token: Token<T>;
    generator: () => T;
};

// @public
export type ErrorCode = 'RECURSIVE_RESOLUTION' | 'BINDING_ERROR' | 'TOKEN_RESOLUTION' | 'INVALID_OPERATION';

// @public
interface FactoryContext<Metadata extends MetadataObject> {
    container: Pick<Container, 'createChild' | 'config'>;
    metadata: Partial<Metadata>;
}

// @public
type Fn<out T, in Args extends unknown[] = any> = (...args: Args) => T;

// Warning: (ae-unresolved-link) The @link reference could not be resolved: This type of declaration is not supported yet by the resolver
//
// @public
type ImplicitScopeBindingOptions = 'toConstantValue';

// @public
export const inject: InjectDecoratorFactory;

// @public
export const injectable: <T extends object, Tokens extends Array<interfaces.InjectionIdentifier<unknown>>>(...constructorTokens: Tokens) => ClassDecorator_2<T, interfaces.ArgsForInjectionIdentifiers<Tokens>>;

// @public
export interface InjectDecoratorFactory {
    // (undocumented)
    <T>(id: interfaces.ServiceIdentifier<T>, options: Partial<interfaces.InjectOptions<interfaces.MetadataForIdentifier<typeof id>>> & {
        multiple: true;
    }): ClassFieldDecorator<object, T[]>;
    // (undocumented)
    <T>(id: interfaces.ServiceIdentifier<T>, options: Partial<interfaces.InjectOptions<interfaces.MetadataForIdentifier<typeof id>>> & {
        optional: true;
    }): ClassFieldDecorator<object, T | undefined>;
    // (undocumented)
    <T>(id: interfaces.ServiceIdentifier<T>, options?: Partial<interfaces.InjectOptions<interfaces.MetadataForIdentifier<typeof id>>>): ClassFieldDecorator<object, T>;
}

// Warning: (ae-unresolved-link) The @link reference could not be resolved: This type of declaration is not supported yet by the resolver
//
// @public
type InjectedMetadata<T extends InjectionIdentifier<unknown>> = T extends [ServiceIdentifierWithMetadata<unknown, infer U>, unknown] ? U : T extends ServiceIdentifierWithMetadata<unknown, infer U> ? U : MetadataObject;

// Warning: (ae-unresolved-link) The @link reference could not be resolved: This type of declaration is not supported yet by the resolver
//
// @public
type InjectedType<T extends InjectionIdentifier<unknown>> = T extends [ServiceIdentifier<infer U>, {
    multiple: true;
}] ? U[] : T extends [ServiceIdentifier<infer U>, {
    optional: true;
}] ? U | undefined : T extends [ServiceIdentifier<infer U>, unknown] ? U : T extends ServiceIdentifier<infer U> ? U : T extends DirectInjection<infer U> ? U : never;

// @public
type InjectionIdentifier<T> = ServiceIdentifier<T> | [ServiceIdentifier<T>, Partial<InjectOptions<MetadataObject>> | undefined] | DirectInjection<T>;

// @public
interface InjectOptions<Metadata extends MetadataObject> {
    metadata: Partial<Metadata>;
    multiple: boolean;
    optional: boolean;
}

declare namespace interfaces {
    export {
        Binder,
        ImplicitScopeBindingOptions,
        BindingBuilder,
        ClassBindingBuilder,
        ObjectBindingBuilder,
        BindingMetadata,
        BindingScope,
        ClassBinder,
        Container,
        ContainerConfiguration,
        ContainerFactory,
        AsyncContainerModule,
        ContainerModule,
        SyncContainerModule,
        DirectInjection,
        FactoryContext,
        Constructor,
        Fn,
        BindFunction,
        IsBoundFunction,
        RebindFunction,
        UnbindFunction,
        ArgsForInjectionIdentifiers,
        InjectedMetadata,
        InjectedType,
        InjectionIdentifier,
        InjectOptions,
        Logger,
        LoggerFn,
        LoggerLevel,
        MetadataObject,
        ObjectBinder,
        ScopeOptions,
        MetadataForIdentifier,
        ServiceIdentifier,
        ServiceIdentifierWithMetadata
    }
}
export { interfaces }

// @public
export class InvalidOperationError extends IocError {
    constructor(msg: string, originalError?: Error);
}

// @public
export abstract class IocError extends Error {
    constructor(msg: string, code: ErrorCode, originalError?: Error);
    readonly cause?: Error;
    readonly code: ErrorCode;
}

// @public
type IsBoundFunction = <T>(id: ServiceIdentifier<T>) => boolean;

// @public
export const isMetadataToken: (o: unknown) => o is MetadataToken<unknown, interfaces.MetadataObject>;

// @public
export const isToken: (o: unknown) => o is AnyToken<unknown>;

// @public
type Logger = Record<LoggerLevel, LoggerFn>;

// @public
type LoggerFn = {
    (obj: Record<string, unknown>, message?: string): void;
    (message: string): void;
};

// @public
type LoggerLevel = 'warn' | 'info' | 'debug' | 'trace';

// @public (undocumented)
type MetadataForIdentifier<Id extends ServiceIdentifier<unknown>> = Id extends ServiceIdentifierWithMetadata<unknown, infer Metadata> ? Metadata : MetadataObject;

// @public
type MetadataObject = Record<string, unknown>;

// @public
export class MetadataToken<out T, Metadata extends interfaces.MetadataObject> {
    constructor(name: string, guard: (o: unknown) => o is Metadata);
    // (undocumented)
    readonly guard: (o: unknown) => o is Metadata;
    // @internal
    readonly identifier: symbol;
    toJSON(): object;
    toString(): string;
    readonly _witness: T;
}

// @public
export const named: <Id extends NamedToken<unknown>>(id: Id, name: string, options?: Partial<interfaces.InjectOptions<{
    name: string;
}>>) => [Id, Partial<interfaces.InjectOptions<{
    name: string;
}>>];

// @public
export class NamedToken<out T> extends MetadataToken<T, {
    name: string;
}> {
    constructor(name: string);
}

// @public
interface ObjectBinder<in out T extends object> {
    to: (fn: Constructor<T>) => void;
}

// @public
interface ObjectBindingBuilder<in out T extends object, in out Metadata extends MetadataObject> extends Binder<T, Metadata>, BindingMetadata<T, Metadata, ObjectBindingBuilder<T, Metadata>>, BindingScope<T, ObjectBindingBuilder<T, Metadata>>, ObjectBinder<T> {
}

// @public
type RebindFunction = BindFunction;

// @public
export class RecursiveResolutionError extends ResolutionError {
    constructor(msg: string, resolutionPath: Array<Token<unknown>>);
}

// @public
export abstract class ResolutionError extends IocError {
    constructor(msg: string, code: ErrorCode, resolutionPath: Array<Token<unknown>>, originalError?: Error);
    readonly resolutionPath: Array<Token<unknown>>;
}

// Warning: (ae-unresolved-link) The @link reference could not be resolved: This type of declaration is not supported yet by the resolver
//
// @public
type ScopeOptions = 'transient' | 'request' | 'singleton';

// @public
type ServiceIdentifier<T> = Token<T> | Constructor<T> | ServiceIdentifierWithMetadata<T, MetadataObject>;

// Warning: (ae-unresolved-link) The @link reference could not be resolved: This type of declaration is not supported yet by the resolver
//
// @public
type ServiceIdentifierWithMetadata<T, Metadata extends MetadataObject> = MetadataToken<T, Metadata>;

// @public
export const stringifyIdentifier: <T>(id: interfaces.ServiceIdentifier<T>) => string;

// @public
type SyncContainerModule = (bind: BindFunction, unbind: UnbindFunction, isBound: IsBoundFunction, rebind: RebindFunction) => void;

// @public
export class Token<out T> {
    constructor(name: string);
    // @internal
    readonly identifier: symbol;
    toJSON(): object;
    toString(): string;
    readonly _witness: T;
}

// @public
export class TokenResolutionError extends ResolutionError {
    constructor(msg: string, resolutionPath: Array<Token<unknown>>, originalError: Error);
    readonly cause: Error;
}

// @public
export type TokenType<T extends {
    _witness: unknown;
}> = T extends {
    _witness: infer U;
} ? U : never;

// @public
type UnbindFunction = <T>(id: ServiceIdentifier<T>) => void;

// @public
export const unmanaged: <T>(defaultValue: T, name?: string) => interfaces.DirectInjection<T>;

// @public
export const withOptions: <Id extends interfaces.ServiceIdentifier<unknown>, Options extends Partial<interfaces.InjectOptions<interfaces.MetadataForIdentifier<Id>>>>(id: Id, options: Options) => [Id, Options];

```
